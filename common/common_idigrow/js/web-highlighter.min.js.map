{"version":3,"sources":["webpack://Highlighter/webpack/universalModuleDefinition","webpack://Highlighter/webpack/bootstrap","webpack://Highlighter/./src/util/const.ts","webpack://Highlighter/./src/types/index.ts","webpack://Highlighter/./src/util/event.emitter.ts","webpack://Highlighter/./src/model/source/index.ts","webpack://Highlighter/./src/util/dom.ts","webpack://Highlighter/./src/model/range/index.ts","webpack://Highlighter/./src/util/uuid.ts","webpack://Highlighter/./src/index.ts","webpack://Highlighter/./src/model/source/dom.ts","webpack://Highlighter/./src/util/camel.ts","webpack://Highlighter/./src/model/range/selection.ts","webpack://Highlighter/./src/model/range/dom.ts","webpack://Highlighter/./src/util/hook.ts","webpack://Highlighter/./src/util/interaction.ts","webpack://Highlighter/./src/util/is.mobile.ts","webpack://Highlighter/./src/data/cache.ts","webpack://Highlighter/./src/painter/index.ts","webpack://Highlighter/./src/painter/dom.ts","webpack://Highlighter/./src/util/tool.ts","webpack://Highlighter/./src/painter/style.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ID_DIVISION","LOCAL_STORE_KEY","STYLESHEET_ID","DATASET_IDENTIFIER","DATASET_IDENTIFIER_EXTRA","DATASET_SPLIT_TYPE","CAMEL_DATASET_IDENTIFIER","CAMEL_DATASET_IDENTIFIER_EXTRA","CAMEL_DATASET_SPLIT_TYPE","getDefaultOptions","$root","document","documentElement","exceptSelectors","wrapTag","verbose","style","className","getStylesheet","ROOT_IDX","UNKNOWN_IDX","INTERNAL_ERROR_EVENT","eventEmitter","ErrorEventEmitter","SplitType","ERROR","EventType","CreateFrom","SelectedNodeType","UserInputEvent","handlersMap","on","type","handler","this","push","off","splice","indexOf","emit","slice","forEach","data","EventEmitter","startMeta","endMeta","text","id","extra","__isHighlightSource","deSerialize","hooks","queryElementNode","start","end","startInfo","getTextChildByOffset","textOffset","endInfo","Serialize","Restore","isEmpty","res","HighlightSource","isHighlightWrapNode","$node","dataset","findAncestorWrapperInRoot","isInsideRoot","$wrapper","parentNode","getHighlightId","getExtraHighlightId","split","filter","getHighlightsByRoot","$roots","Array","isArray","$wraps","$list","querySelectorAll","apply","getHighlightById","$highlights","reg","RegExp","$n","extraId","test","$nodes","cb","length","removeEventListener","$el","evt","fn","addEventListener","addClass","classList","add","removeClass","remove","removeAllClass","hasClass","contains","frozen","nodeType","RANGE_NODE_INVALID","formatDomNode","fromSelection","idHook","range","getDomRange","startContainer","offset","startOffset","endContainer","endOffset","toString","HighlightRange","serialize","getDomMeta","RecordInfo","removeDomRange","removeSelection","createUUID","a","Math","random","replace","options","event","run","PointerEnd","_handleSelection","stop","getDoms","getIdByDom","getExtraIdByDom","dispose","PointerOver","_handleHighlightHover","PointerTap","_handleHighlightClick","removeAll","setOption","painter","fromRange","Render","UUID","hRange","_highlightFromHRange","RANGE_INVALID","fromStore","hs","_highlightFromHSource","err","HIGHLIGHT_SOURCE_RECREATE","error","detail","_getHooks","SelectedNodes","WrapNode","Remove","UpdateNodes","source","highlightRange","DOM_SELECTION_EMPTY","cache","save","CREATE","sources","INPUT","e","$target","target","_hoverId","HOVER_OUT","HOVER","_handleError","console","warn","CLICK","doseExist","removeHighlight","REMOVE","ids","removeAllHighlight","renderedSources","highlightSource","STORE","isHighlightSource","Highlighter","$parent","nodeStack","$curNode","curOffset","pop","children","childNodes","textContent","parentIndex","getElementsByTagName","parentTagName","reduce","str","idx","toUpperCase","selection","getSelection","isCollapsed","debug","getRangeAt","removeAllRanges","$originParent","HTMLElement","getOriginParent","index","tagName","countGlobalNodeIndex","preNodeOffset","$text","getTextPreOffset","ops","tap","ret","op","args","Hook","isMobile","navigator","userAgent","touchend","mouseup","touchstart","click","mouseover","regMobile","_data","Map","getAll","map","CACHE_SET_ERROR","set","delete","list","pair","Cache","initDefaultStylesheet","HIGHLIGHT_RANGE_FROZEN","$selectedNodes","getSelectedNodes","wrapHighlight","HIGHLIGHT_SOURCE_NONE_RENDER","SOURCE_TYPE_ERROR","$spans","$toRemove","$idToUpdate","$extraToUpdate","$s","spanId","spanExtraIds","$fr","createDocumentFragment","$c","appendChild","cloneNode","$prev","previousSibling","$next","nextSibling","replaceChild","normalizeSiblingText","newId","shift","$overlapSpan","querySelector","join","extraIds","isMatchSelector","selector","$startNode","$endNode","Text","$element","isExcepted","$e","some","splitText","passedNode","splitType","both","getNodesIfSameStartEnd","selectedNodes","withinSelectedRange","curNode","node","head","tail","none","classNames","isNodeEmpty","selected","$wrap","formerId","wrapOverlapNode","createElement","parentId","parentExtraId","extraInfo","setAttribute","headSplit","tailSplit","$span","classNameList","unique","wrapPartialNode","wrapNewNode","isNext","$sibling","nodeValue","removeChild","arr","el","styleId","$style","getElementById","$cssNode","createTextNode"],"mappings":"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","file":"web-highlighter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highlighter\"] = factory();\n\telse\n\t\troot[\"Highlighter\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\n * all constants\n * cSpell:ignore mengshou\n */\n\nimport type HighlightSource from '@src/model/source';\nimport type { ERROR } from '@src/types';\nimport camel from '@src/util/camel';\nimport EventEmitter from '@src/util/event.emitter';\n\nexport const ID_DIVISION = ';';\nexport const LOCAL_STORE_KEY = 'highlight-mengshou';\nexport const STYLESHEET_ID = 'highlight-mengshou-style';\n\nexport const DATASET_IDENTIFIER = 'highlight-id';\nexport const DATASET_IDENTIFIER_EXTRA = 'highlight-id-extra';\nexport const DATASET_SPLIT_TYPE = 'highlight-split-type';\nexport const CAMEL_DATASET_IDENTIFIER = camel(DATASET_IDENTIFIER);\nexport const CAMEL_DATASET_IDENTIFIER_EXTRA = camel(DATASET_IDENTIFIER_EXTRA);\nexport const CAMEL_DATASET_SPLIT_TYPE = camel(DATASET_SPLIT_TYPE);\n\nconst DEFAULT_WRAP_TAG = 'span';\n\nexport const getDefaultOptions = () => ({\n    $root: document || document.documentElement,\n    exceptSelectors: null,\n    wrapTag: DEFAULT_WRAP_TAG,\n    verbose: false,\n    style: {\n        className: 'highlight-mengshou-wrap',\n    },\n});\n\nexport const getStylesheet = () => `\n    .${getDefaultOptions().style.className} {\n        background: #ff9;\n        cursor: pointer;\n    }\n    .${getDefaultOptions().style.className}.active {\n        background: #ffb;\n    }\n`;\n\nexport const ROOT_IDX = -2;\nexport const UNKNOWN_IDX = -1;\nexport const INTERNAL_ERROR_EVENT = 'error';\n\ninterface EventHandlerMap {\n    [key: string]: (...args: any[]) => void;\n    error: (data: { type: ERROR; detail?: HighlightSource; error?: any }) => void;\n}\nclass ErrorEventEmitter extends EventEmitter<EventHandlerMap> {}\n\nexport const eventEmitter = new ErrorEventEmitter();\n","import type Hook from '@src/util/hook';\n\nexport type RootElement = Document | HTMLElement;\n\nexport interface HighlighterOptions {\n    $root?: RootElement;\n    exceptSelectors?: string[];\n    wrapTag?: string;\n    verbose?: boolean;\n    style?: {\n        className?: string[] | string;\n    };\n}\n\nexport interface PainterOptions {\n    $root: RootElement;\n    wrapTag: string;\n    className: string[] | string;\n    exceptSelectors: string[];\n}\n\nexport enum SplitType {\n    none = 'none',\n    head = 'head',\n    tail = 'tail',\n    both = 'both',\n}\n\nexport enum ERROR {\n    DOM_TYPE_ERROR = '[DOM] Receive wrong node type.',\n    DOM_SELECTION_EMPTY = '[DOM] The selection contains no dom node, may be you except them.',\n    RANGE_INVALID = \"[RANGE] Got invalid dom range, can't convert to a valid highlight range.\",\n    RANGE_NODE_INVALID = \"[RANGE] Start or end node isn't a text node, it may occur an error.\",\n    DB_ID_DUPLICATE_ERROR = '[STORE] Unique id conflict.',\n    CACHE_SET_ERROR = \"[CACHE] Cache.data can't be set manually, please use .save().\",\n    SOURCE_TYPE_ERROR = \"[SOURCE] Object isn't a highlight source instance.\",\n    HIGHLIGHT_RANGE_FROZEN = '[HIGHLIGHT_RANGE] A highlight range must be frozen before render.',\n    HIGHLIGHT_SOURCE_RECREATE = '[HIGHLIGHT_SOURCE] Recreate highlights from sources error.',\n    // eslint-disable-next-line max-len\n    HIGHLIGHT_SOURCE_NONE_RENDER = \"[HIGHLIGHT_SOURCE] This highlight source isn't rendered. May be the exception skips it or the dom structure has changed.\",\n}\n\nexport enum EventType {\n    CREATE = 'selection:create',\n    REMOVE = 'selection:remove',\n    MODIFY = 'selection:modify',\n    HOVER = 'selection:hover',\n    HOVER_OUT = 'selection:hover-out',\n    CLICK = 'selection:click',\n}\n\nexport enum CreateFrom {\n    STORE = 'from-store',\n    INPUT = 'from-input',\n}\n\nexport enum SelectedNodeType {\n    text = 'text',\n    span = 'span',\n}\n\nexport interface SelectedNode {\n    $node: Node | Text;\n    type: SelectedNodeType;\n    splitType: SplitType;\n}\n\nexport interface DomMeta {\n    parentTagName: string;\n    parentIndex: number;\n    textOffset: number;\n    extra?: unknown;\n}\n\nexport interface DomNode {\n    $node: Node;\n    offset: number;\n}\n\nexport interface HighlightPosition {\n    start: {\n        top: number;\n        left: number;\n    };\n    end: {\n        top: number;\n        left: number;\n    };\n}\n\nexport interface HookMap {\n    Render: {\n        UUID: Hook<string>;\n        SelectedNodes: Hook<SelectedNode[]>;\n        WrapNode: Hook<HTMLElement>;\n    };\n    Serialize: {\n        Restore: Hook<DomNode[]>;\n        RecordInfo: Hook<string>;\n    };\n    Remove: {\n        UpdateNodes: Hook;\n    };\n}\n\nexport enum UserInputEvent {\n    touchend = 'touchend',\n    mouseup = 'mouseup',\n    touchstart = 'touchstart',\n    click = 'click',\n    mouseover = 'mouseover',\n}\n\nexport interface IInteraction {\n    PointerEnd: UserInputEvent;\n    PointerTap: UserInputEvent;\n    PointerOver: UserInputEvent;\n}\n","/**\n * tiny event emitter\n * modify from mitt\n */\n\ntype EventHandler = (...data: unknown[]) => void;\n\ntype EventMap = Record<string, EventHandler>;\ntype HandlersMap<T extends EventMap> = {\n    [K in keyof T]: T[K][];\n};\n\nclass EventEmitter<U extends EventMap = EventMap> {\n    private handlersMap: HandlersMap<U> = Object.create(null);\n\n    on<T extends keyof U>(type: T, handler: U[T]) {\n        if (!this.handlersMap[type]) {\n            this.handlersMap[type] = [];\n        }\n\n        this.handlersMap[type].push(handler);\n\n        return this;\n    }\n\n    off<T extends keyof U>(type: T, handler: U[T]) {\n        if (this.handlersMap[type]) {\n            this.handlersMap[type].splice(this.handlersMap[type].indexOf(handler) >>> 0, 1);\n        }\n\n        return this;\n    }\n\n    emit<T extends keyof U>(type: T, ...data: Parameters<U[T]>) {\n        if (this.handlersMap[type]) {\n            this.handlersMap[type].slice().forEach(handler => {\n                handler(...data);\n            });\n        }\n\n        return this;\n    }\n}\n\nexport default EventEmitter;\n","/**\n * HighlightSource Class (HSource)\n * This Object can be deSerialized to HRange.\n * Also it has the ability for persistence.\n */\n\nimport type { DomMeta, HookMap, DomNode } from '@src/types';\nimport HighlightRange from '@src/model/range/index';\nimport { queryElementNode, getTextChildByOffset } from '@src/model/source/dom';\n\nclass HighlightSource {\n    startMeta: DomMeta;\n\n    endMeta: DomMeta;\n\n    text: string;\n\n    id: string;\n\n    extra?: unknown;\n\n    __isHighlightSource: unknown;\n\n    constructor(startMeta: DomMeta, endMeta: DomMeta, text: string, id: string, extra?: unknown) {\n        this.startMeta = startMeta;\n        this.endMeta = endMeta;\n        this.text = text;\n        this.id = id;\n        this.__isHighlightSource = {};\n\n        if (extra) {\n            this.extra = extra;\n        }\n    }\n\n    deSerialize($root: Document | HTMLElement, hooks: HookMap): HighlightRange {\n        const { start, end } = queryElementNode(this, $root);\n        let startInfo = getTextChildByOffset(start, this.startMeta.textOffset);\n        let endInfo = getTextChildByOffset(end, this.endMeta.textOffset);\n\n        if (!hooks.Serialize.Restore.isEmpty()) {\n            const res: DomNode[] = hooks.Serialize.Restore.call(this, startInfo, endInfo) || [];\n\n            startInfo = res[0] || startInfo;\n            endInfo = res[1] || endInfo;\n        }\n\n        const range = new HighlightRange(startInfo, endInfo, this.text, this.id, true);\n\n        return range;\n    }\n}\n\nexport default HighlightSource;\n","import type { RootElement } from '@src/types';\nimport {\n    ID_DIVISION,\n    DATASET_IDENTIFIER,\n    CAMEL_DATASET_IDENTIFIER,\n    CAMEL_DATASET_IDENTIFIER_EXTRA,\n} from '@src/util/const';\n\n/**\n * whether a wrapper node\n */\nexport const isHighlightWrapNode = ($node: HTMLElement): boolean =>\n    !!$node.dataset && !!$node.dataset[CAMEL_DATASET_IDENTIFIER];\n\n/**\n * ===================================================================================\n * below methods (getHighlightId/getExtraHighlightId)\n * will check whether the node is inside a wrapper iteratively util reach the root node\n * if the node is not inside the root, the id must be empty\n * ====================================================================================\n */\n\nconst findAncestorWrapperInRoot = ($node: HTMLElement, $root: RootElement): HTMLElement => {\n    let isInsideRoot = false;\n    let $wrapper: HTMLElement = null;\n\n    while ($node) {\n        if (isHighlightWrapNode($node)) {\n            $wrapper = $node;\n        }\n\n        if ($node === $root) {\n            isInsideRoot = true;\n            break;\n        }\n\n        $node = $node.parentNode as HTMLElement;\n    }\n\n    return isInsideRoot ? $wrapper : null;\n};\n\n/**\n * get highlight id by a node\n */\nexport const getHighlightId = ($node: HTMLElement, $root: RootElement): string => {\n    $node = findAncestorWrapperInRoot($node, $root);\n\n    if (!$node) {\n        return '';\n    }\n\n    return $node.dataset[CAMEL_DATASET_IDENTIFIER];\n};\n\n/**\n * get extra highlight id by a node\n */\nexport const getExtraHighlightId = ($node: HTMLElement, $root: RootElement): string[] => {\n    $node = findAncestorWrapperInRoot($node, $root);\n\n    if (!$node) {\n        return [];\n    }\n\n    return $node.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA].split(ID_DIVISION).filter(i => i);\n};\n\n/**\n * get all highlight wrapping nodes nodes from a root node\n */\nexport const getHighlightsByRoot = ($roots: RootElement | RootElement[], wrapTag: string): HTMLElement[] => {\n    if (!Array.isArray($roots)) {\n        $roots = [$roots];\n    }\n\n    const $wraps: HTMLElement[] = [];\n\n    for (const $r of $roots) {\n        const $list = $r.querySelectorAll<HTMLElement>(`${wrapTag}[data-${DATASET_IDENTIFIER}]`);\n\n        // eslint-disable-next-line prefer-spread\n        $wraps.push.apply($wraps, $list);\n    }\n\n    return $wraps;\n};\n\n/**\n * get all highlight wrapping nodes by highlight id from a root node\n */\nexport const getHighlightById = ($root: RootElement, id: string, wrapTag: string): HTMLElement[] => {\n    const $highlights: HTMLElement[] = [];\n    const reg = new RegExp(`(${id}\\\\${ID_DIVISION}|\\\\${ID_DIVISION}?${id}$)`);\n    const $list = $root.querySelectorAll<HTMLElement>(`${wrapTag}[data-${DATASET_IDENTIFIER}]`);\n\n    for (const $l of $list) {\n        const $n = $l;\n        const nid = $n.dataset[CAMEL_DATASET_IDENTIFIER];\n\n        if (nid === id) {\n            $highlights.push($n);\n            continue;\n        }\n\n        const extraId = $n.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA];\n\n        if (reg.test(extraId)) {\n            $highlights.push($n);\n            continue;\n        }\n    }\n\n    return $highlights;\n};\n\nexport const forEach = ($nodes: NodeList, cb: (n: Node, idx: number, s: NodeList) => void): void => {\n    for (let i = 0; i < $nodes.length; i++) {\n        cb($nodes[i], i, $nodes);\n    }\n};\n\nexport const removeEventListener = ($el: RootElement, evt: string, fn: EventListenerOrEventListenerObject) => {\n    $el.removeEventListener(evt, fn);\n};\n\n/**\n * maybe be need some polyfill methods later\n * provide unified dom methods for compatibility\n */\nexport const addEventListener = ($el: RootElement, evt: string, fn: EventListenerOrEventListenerObject) => {\n    $el.addEventListener(evt, fn);\n\n    return () => {\n        removeEventListener($el, evt, fn);\n    };\n};\n\nexport const addClass = ($el: HTMLElement, className: string[] | string) => {\n    if (!Array.isArray(className)) {\n        className = [className];\n    }\n\n    $el.classList.add(...className);\n};\n\nexport const removeClass = ($el: HTMLElement, className: string): void => {\n    $el.classList.remove(className);\n};\n\nexport const removeAllClass = ($el: HTMLElement): void => {\n    $el.className = '';\n};\n\nexport const hasClass = ($el: HTMLElement, className: string): boolean => $el.classList.contains(className);\n","/**\n * the HighlightRange Class（HRange）\n * It's a special object called HRange in Highlighter,\n * represents for a piece of chosen dom\n */\n\nimport type { DomNode, HookMap } from '@src/types';\nimport type Hook from '@src/util/hook';\nimport HighlightSource from '@src/model/source/index';\nimport { ERROR } from '@src/types';\nimport { getDomRange, removeSelection } from '@src/model/range/selection';\nimport uuid from '@src/util/uuid';\nimport { getDomMeta, formatDomNode } from '@src/model/range/dom';\nimport { eventEmitter, INTERNAL_ERROR_EVENT } from '@src/util/const';\n\nclass HighlightRange {\n    static removeDomRange = removeSelection;\n\n    start: DomNode;\n\n    end: DomNode;\n\n    text: string;\n\n    id: string;\n\n    frozen: boolean;\n\n    constructor(start: DomNode, end: DomNode, text: string, id: string, frozen = false) {\n        if (start.$node.nodeType !== 3 || end.$node.nodeType !== 3) {\n            eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                type: ERROR.RANGE_NODE_INVALID,\n            });\n        }\n\n        this.start = formatDomNode(start);\n        this.end = formatDomNode(end);\n        this.text = text;\n        this.frozen = frozen;\n        this.id = id;\n    }\n\n    static fromSelection(idHook: Hook<string>) {\n        const range = getDomRange();\n\n        if (!range) {\n            return null;\n        }\n\n        const start: DomNode = {\n            $node: range.startContainer,\n            offset: range.startOffset,\n        };\n        const end: DomNode = {\n            $node: range.endContainer,\n            offset: range.endOffset,\n        };\n\n        const text = range.toString();\n        let id = idHook.call(start, end, text);\n\n        id = typeof id !== 'undefined' && id !== null ? id : uuid();\n\n        return new HighlightRange(start, end, text, id);\n    }\n\n    // serialize the HRange instance\n    // so that you can save the returned object (e.g. use JSON.stringify on it and send to backend)\n    serialize($root: Document | HTMLElement, hooks: HookMap): HighlightSource {\n        const startMeta = getDomMeta(this.start.$node as Text, this.start.offset, $root);\n        const endMeta = getDomMeta(this.end.$node as Text, this.end.offset, $root);\n\n        let extra;\n\n        if (!hooks.Serialize.RecordInfo.isEmpty()) {\n            extra = hooks.Serialize.RecordInfo.call(this.start, this.end, $root);\n        }\n\n        this.frozen = true;\n\n        return new HighlightSource(startMeta, endMeta, this.text, this.id, extra);\n    }\n}\n\nexport default HighlightRange;\n","/**\n * generate UUID\n */\n\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\nexport default function createUUID(a?): string {\n    return a\n        ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)\n        : ((([1e7] as unknown) as string) + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, createUUID);\n}\n","import type { DomNode, DomMeta, HookMap, HighlighterOptions } from '@src/types';\nimport EventEmitter from '@src/util/event.emitter';\nimport HighlightRange from '@src/model/range';\nimport HighlightSource from '@src/model/source';\nimport uuid from '@src/util/uuid';\nimport Hook from '@src/util/hook';\nimport getInteraction from '@src/util/interaction';\nimport Cache from '@src/data/cache';\nimport Painter from '@src/painter';\nimport { eventEmitter, getDefaultOptions, INTERNAL_ERROR_EVENT } from '@src/util/const';\nimport { ERROR, EventType, CreateFrom } from '@src/types';\nimport {\n    addClass,\n    removeClass,\n    isHighlightWrapNode,\n    getHighlightById,\n    getExtraHighlightId,\n    getHighlightsByRoot,\n    getHighlightId,\n    addEventListener,\n    removeEventListener,\n} from '@src/util/dom';\n\ninterface EventHandlerMap {\n    [key: string]: (...args: any[]) => void;\n    [EventType.CLICK]: (data: { id: string }, h: Highlighter, e: MouseEvent | TouchEvent) => void;\n    [EventType.HOVER]: (data: { id: string }, h: Highlighter, e: MouseEvent | TouchEvent) => void;\n    [EventType.HOVER_OUT]: (data: { id: string }, h: Highlighter, e: MouseEvent | TouchEvent) => void;\n    [EventType.CREATE]: (data: { sources: HighlightSource[]; type: CreateFrom }, h: Highlighter) => void;\n    [EventType.REMOVE]: (data: { ids: string[] }, h: Highlighter) => void;\n}\n\nexport default class Highlighter extends EventEmitter<EventHandlerMap> {\n    static event = EventType;\n\n    static isHighlightWrapNode = isHighlightWrapNode;\n\n    hooks: HookMap;\n\n    painter: Painter;\n\n    cache: Cache;\n\n    private _hoverId: string;\n\n    private options: HighlighterOptions;\n\n    private readonly event = getInteraction();\n\n    constructor(options?: HighlighterOptions) {\n        super();\n        this.options = getDefaultOptions();\n        // initialize hooks\n        this.hooks = this._getHooks();\n        this.setOption(options);\n        // initialize cache\n        this.cache = new Cache();\n\n        const $root = this.options.$root;\n\n        // initialize event listener\n        addEventListener($root, this.event.PointerOver, this._handleHighlightHover);\n        // initialize event listener\n        addEventListener($root, this.event.PointerTap, this._handleHighlightClick);\n        eventEmitter.on(INTERNAL_ERROR_EVENT, this._handleError);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    static isHighlightSource = (d: any) => !!d.__isHighlightSource;\n\n    run = () => addEventListener(this.options.$root, this.event.PointerEnd, this._handleSelection);\n\n    stop = () => {\n        removeEventListener(this.options.$root, this.event.PointerEnd, this._handleSelection);\n    };\n\n    addClass = (className: string, id?: string) => {\n        this.getDoms(id).forEach($n => {\n            addClass($n, className);\n        });\n    };\n\n    removeClass = (className: string, id?: string) => {\n        this.getDoms(id).forEach($n => {\n            removeClass($n, className);\n        });\n    };\n\n    getIdByDom = ($node: HTMLElement): string => getHighlightId($node, this.options.$root);\n\n    getExtraIdByDom = ($node: HTMLElement): string[] => getExtraHighlightId($node, this.options.$root);\n\n    getDoms = (id?: string): HTMLElement[] =>\n        id\n            ? getHighlightById(this.options.$root, id, this.options.wrapTag)\n            : getHighlightsByRoot(this.options.$root, this.options.wrapTag);\n\n    dispose = () => {\n        const $root = this.options.$root;\n\n        removeEventListener($root, this.event.PointerOver, this._handleHighlightHover);\n        removeEventListener($root, this.event.PointerEnd, this._handleSelection);\n        removeEventListener($root, this.event.PointerTap, this._handleHighlightClick);\n        this.removeAll();\n    };\n\n    setOption = (options?: HighlighterOptions) => {\n        this.options = {\n            ...this.options,\n            ...options,\n        };\n        this.painter = new Painter(\n            {\n                $root: this.options.$root,\n                wrapTag: this.options.wrapTag,\n                className: this.options.style.className,\n                exceptSelectors: this.options.exceptSelectors,\n            },\n            this.hooks,\n        );\n    };\n\n    fromRange = (range: Range): HighlightSource => {\n        const start: DomNode = {\n            $node: range.startContainer,\n            offset: range.startOffset,\n        };\n        const end: DomNode = {\n            $node: range.endContainer,\n            offset: range.endOffset,\n        };\n\n        const text = range.toString();\n        let id = this.hooks.Render.UUID.call(start, end, text);\n\n        id = typeof id !== 'undefined' && id !== null ? id : uuid();\n\n        const hRange = new HighlightRange(start, end, text, id);\n\n        if (!hRange) {\n            eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                type: ERROR.RANGE_INVALID,\n            });\n\n            return null;\n        }\n\n        return this._highlightFromHRange(hRange);\n    };\n\n    fromStore = (start: DomMeta, end: DomMeta, text: string, id: string, extra?: unknown): HighlightSource => {\n        const hs = new HighlightSource(start, end, text, id, extra);\n\n        try {\n            this._highlightFromHSource(hs);\n\n            return hs;\n        } catch (err: unknown) {\n            eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                type: ERROR.HIGHLIGHT_SOURCE_RECREATE,\n                error: err,\n                detail: hs,\n            });\n\n            return null;\n        }\n    };\n\n    remove(id: string) {\n        if (!id) {\n            return;\n        }\n\n        const doseExist = this.painter.removeHighlight(id);\n\n        this.cache.remove(id);\n\n        // only emit REMOVE event when highlight exist\n        if (doseExist) {\n            this.emit(EventType.REMOVE, { ids: [id] }, this);\n        }\n    }\n\n    removeAll() {\n        this.painter.removeAllHighlight();\n\n        const ids = this.cache.removeAll();\n\n        this.emit(EventType.REMOVE, { ids }, this);\n    }\n\n    private readonly _getHooks = (): HookMap => ({\n        Render: {\n            UUID: new Hook('Render.UUID'),\n            SelectedNodes: new Hook('Render.SelectedNodes'),\n            WrapNode: new Hook('Render.WrapNode'),\n        },\n        Serialize: {\n            Restore: new Hook('Serialize.Restore'),\n            RecordInfo: new Hook('Serialize.RecordInfo'),\n        },\n        Remove: {\n            UpdateNodes: new Hook('Remove.UpdateNodes'),\n        },\n    });\n\n    private readonly _highlightFromHRange = (range: HighlightRange): HighlightSource => {\n        const source: HighlightSource = range.serialize(this.options.$root, this.hooks);\n        const $wraps = this.painter.highlightRange(range);\n\n        if ($wraps.length === 0) {\n            eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                type: ERROR.DOM_SELECTION_EMPTY,\n            });\n\n            return null;\n        }\n\n        this.cache.save(source);\n        this.emit(EventType.CREATE, { sources: [source], type: CreateFrom.INPUT }, this);\n\n        return source;\n    };\n\n    private _highlightFromHSource(sources: HighlightSource | HighlightSource[] = []) {\n        const renderedSources: HighlightSource[] = this.painter.highlightSource(sources);\n\n        this.emit(EventType.CREATE, { sources: renderedSources, type: CreateFrom.STORE }, this);\n        this.cache.save(sources);\n    }\n\n    private readonly _handleSelection = () => {\n        const range = HighlightRange.fromSelection(this.hooks.Render.UUID);\n\n        if (range) {\n            this._highlightFromHRange(range);\n            HighlightRange.removeDomRange();\n        }\n    };\n\n    private readonly _handleHighlightHover = (e: MouseEvent | TouchEvent) => {\n        const $target = e.target as HTMLElement;\n\n        if (!isHighlightWrapNode($target)) {\n            this._hoverId && this.emit(EventType.HOVER_OUT, { id: this._hoverId }, this, e);\n            this._hoverId = null;\n\n            return;\n        }\n\n        const id = getHighlightId($target, this.options.$root);\n\n        // prevent trigger in the same highlight range\n        if (this._hoverId === id) {\n            return;\n        }\n\n        // hover another highlight range, need to trigger previous highlight hover out event\n        if (this._hoverId) {\n            this.emit(EventType.HOVER_OUT, { id: this._hoverId }, this, e);\n        }\n\n        this._hoverId = id;\n        this.emit(EventType.HOVER, { id: this._hoverId }, this, e);\n    };\n\n    private readonly _handleError = (type: { type: ERROR; detail?: HighlightSource; error?: any }) => {\n        if (this.options.verbose) {\n            // eslint-disable-next-line no-console\n            console.warn(type);\n        }\n    };\n\n    private readonly _handleHighlightClick = (e: MouseEvent | TouchEvent) => {\n        const $target = e.target as HTMLElement;\n\n        if (isHighlightWrapNode($target)) {\n            const id = getHighlightId($target, this.options.$root);\n\n            this.emit(EventType.CLICK, { id }, this, e);\n        }\n    };\n}\n","import type { DomNode } from '@src//types';\nimport type HighlightSource from '@src/model/source/index';\nimport { ROOT_IDX } from '@src/util/const';\n\n/**\n * Because of supporting highlighting a same area (range overlapping),\n * Highlighter will calculate which text-node and how much offset it actually be,\n * based on the origin website dom node and the text offset.\n *\n * @param {Node} $parent element node in the origin website dom tree\n * @param {number} offset text offset in the origin website dom tree\n * @return {DomNode} DOM a dom info object\n */\nexport const getTextChildByOffset = ($parent: Node, offset: number): DomNode => {\n    const nodeStack: Node[] = [$parent];\n\n    let $curNode: Node = null;\n    let curOffset = 0;\n    let startOffset = 0;\n\n    while (($curNode = nodeStack.pop())) {\n        const children = $curNode.childNodes;\n\n        for (let i = children.length - 1; i >= 0; i--) {\n            nodeStack.push(children[i]);\n        }\n\n        if ($curNode.nodeType === 3) {\n            startOffset = offset - curOffset;\n            curOffset += $curNode.textContent.length;\n\n            if (curOffset >= offset) {\n                break;\n            }\n        }\n    }\n\n    if (!$curNode) {\n        $curNode = $parent;\n    }\n\n    return {\n        $node: $curNode,\n        offset: startOffset,\n    };\n};\n\n/**\n * get start and end parent element from meta info\n *\n * @param {HighlightSource} hs\n * @param {HTMLElement | Document} $root root element, default document\n * @return {Object}\n */\nexport const queryElementNode = (hs: HighlightSource, $root: Document | HTMLElement): { start: Node; end: Node } => {\n    const start =\n        hs.startMeta.parentIndex === ROOT_IDX\n            ? $root\n            : $root.getElementsByTagName(hs.startMeta.parentTagName)[hs.startMeta.parentIndex];\n    const end =\n        hs.endMeta.parentIndex === ROOT_IDX\n            ? $root\n            : $root.getElementsByTagName(hs.endMeta.parentTagName)[hs.endMeta.parentIndex];\n\n    return { start, end };\n};\n","/**\n * convert dash-joined string to camel case\n */\n\nexport default (a: string): string =>\n    a.split('-').reduce((str, s, idx) => str + (idx === 0 ? s : s[0].toUpperCase() + s.slice(1)), '');\n","/**\n * Something about the Selection/Range API in browsers.\n * If you want to use Highlighter in some old browsers, you may use a polyfill.\n * https://caniuse.com/#search=selection\n */\n\nexport const getDomRange = (): Range => {\n    const selection = window.getSelection();\n\n    if (selection.isCollapsed) {\n        // eslint-disable-next-line no-console\n        console.debug('no text selected');\n\n        return null;\n    }\n\n    return selection.getRangeAt(0);\n};\n\nexport const removeSelection = (): void => {\n    window.getSelection().removeAllRanges();\n};\n","/**\n * some dom operations about HighlightRange\n */\n\nimport type { DomMeta, DomNode } from '@src/types';\nimport { CAMEL_DATASET_IDENTIFIER, ROOT_IDX, UNKNOWN_IDX } from '@src/util/const';\n\nconst countGlobalNodeIndex = ($node: Node, $root: Document | HTMLElement): number => {\n    const tagName = ($node as HTMLElement).tagName;\n    const $list = $root.getElementsByTagName(tagName);\n\n    for (let i = 0; i < $list.length; i++) {\n        if ($node === $list[i]) {\n            return i;\n        }\n    }\n\n    return UNKNOWN_IDX;\n};\n\n/**\n * text total length in all predecessors (text nodes) in the root node\n * (without offset in current node)\n */\nconst getTextPreOffset = ($root: Node, $text: Node): number => {\n    const nodeStack: Node[] = [$root];\n\n    let $curNode: Node = null;\n    let offset = 0;\n\n    while (($curNode = nodeStack.pop())) {\n        const children = $curNode.childNodes;\n\n        for (let i = children.length - 1; i >= 0; i--) {\n            nodeStack.push(children[i]);\n        }\n\n        if ($curNode.nodeType === 3 && $curNode !== $text) {\n            offset += $curNode.textContent.length;\n        } else if ($curNode.nodeType === 3) {\n            break;\n        }\n    }\n\n    return offset;\n};\n\n/**\n * find the original dom parent node (none highlight dom)\n */\nconst getOriginParent = ($node: HTMLElement | Text): HTMLElement => {\n    if ($node instanceof HTMLElement && (!$node.dataset || !$node.dataset[CAMEL_DATASET_IDENTIFIER])) {\n        return $node;\n    }\n\n    let $originParent = $node.parentNode as HTMLElement;\n\n    while ($originParent?.dataset[CAMEL_DATASET_IDENTIFIER]) {\n        $originParent = $originParent.parentNode as HTMLElement;\n    }\n\n    return $originParent;\n};\n\nexport const getDomMeta = ($node: HTMLElement | Text, offset: number, $root: Document | HTMLElement): DomMeta => {\n    const $originParent = getOriginParent($node);\n    const index = $originParent === $root ? ROOT_IDX : countGlobalNodeIndex($originParent, $root);\n    const preNodeOffset = getTextPreOffset($originParent, $node);\n    const tagName = $originParent.tagName;\n\n    return {\n        parentTagName: tagName,\n        parentIndex: index,\n        textOffset: preNodeOffset + offset,\n    };\n};\n\nexport const formatDomNode = (n: DomNode): DomNode => {\n    if (\n        // Text\n        n.$node.nodeType === 3 ||\n        // CDATASection\n        n.$node.nodeType === 4 ||\n        // Comment\n        n.$node.nodeType === 8\n    ) {\n        return n;\n    }\n\n    return {\n        $node: n.$node.childNodes[n.offset],\n        offset: 0,\n    };\n};\n","/**\n * simple hook\n * webpack-plugin-liked api\n */\n\ntype HookCallback<T> = (...args: unknown[]) => T;\n\nclass Hook<T = unknown> {\n    name = '';\n\n    private readonly ops: HookCallback<T>[] = [];\n\n    constructor(name?) {\n        this.name = name;\n    }\n\n    tap(cb: HookCallback<T>) {\n        if (this.ops.indexOf(cb) === -1) {\n            this.ops.push(cb);\n        }\n\n        return () => {\n            this.remove(cb);\n        };\n    }\n\n    remove(cb: HookCallback<T>) {\n        const idx = this.ops.indexOf(cb);\n\n        if (idx < 0) {\n            return;\n        }\n\n        this.ops.splice(idx, 1);\n    }\n\n    isEmpty() {\n        return this.ops.length === 0;\n    }\n\n    call(...args: unknown[]) {\n        let ret: T;\n\n        this.ops.forEach(op => {\n            ret = op(...args);\n        });\n\n        return ret;\n    }\n}\n\nexport default Hook;\n","/**\n * adapter for mobile and desktop events\n */\n\nimport type { IInteraction } from '@src/types';\nimport { UserInputEvent } from '@src/types';\nimport detectMobile from '@src/util/is.mobile';\n\nexport default (): IInteraction => {\n    const isMobile = detectMobile(window.navigator.userAgent);\n\n    const interaction: IInteraction = {\n        PointerEnd: isMobile ? UserInputEvent.touchend : UserInputEvent.mouseup,\n        PointerTap: isMobile ? UserInputEvent.touchstart : UserInputEvent.click,\n        // hover and click will be the same event in mobile\n        PointerOver: isMobile ? UserInputEvent.touchstart : UserInputEvent.mouseover,\n    };\n\n    return interaction;\n};\n","/**\n * is mobile device?\n */\n\nconst regMobile = /Android|iPhone|BlackBerry|BB10|Opera Mini|Phone|Mobile|Silk|Windows Phone|Mobile(?:.+)Firefox\\b/i;\n\nexport default (userAgent: string) => regMobile.test(userAgent);\n","import EventEmitter from '@src/util/event.emitter';\nimport type HighlightSource from '@src/model/source';\nimport { ERROR } from '@src/types';\n\nclass Cache extends EventEmitter {\n    private _data: Map<string, HighlightSource> = new Map();\n\n    get data() {\n        return this.getAll();\n    }\n\n    set data(map) {\n        throw ERROR.CACHE_SET_ERROR;\n    }\n\n    save(source: HighlightSource | HighlightSource[]): void {\n        if (!Array.isArray(source)) {\n            this._data.set(source.id, source);\n\n            return;\n        }\n\n        source.forEach(s => this._data.set(s.id, s));\n    }\n\n    get(id: string): HighlightSource {\n        return this._data.get(id);\n    }\n\n    remove(id: string): void {\n        this._data.delete(id);\n    }\n\n    getAll(): HighlightSource[] {\n        const list: HighlightSource[] = [];\n\n        for (const pair of this._data) {\n            list.push(pair[1]);\n        }\n\n        return list;\n    }\n\n    removeAll(): string[] {\n        const ids: string[] = [];\n\n        for (const pair of this._data) {\n            ids.push(pair[0]);\n        }\n\n        this._data = new Map();\n\n        return ids;\n    }\n}\n\nexport default Cache;\n","/**\n * Painter object is designed for some painting work about higlighting,\n * including rendering, cleaning...\n * No need to instantiate repeatly. A Highlighter instance will bind a Painter instance.\n */\n\nimport type HighlightRange from '@src/model/range';\nimport type { PainterOptions, HookMap } from '@src/types';\nimport HighlightSource from '@src/model/source';\nimport { wrapHighlight, getSelectedNodes, normalizeSiblingText } from '@src/painter/dom';\nimport { getHighlightsByRoot, forEach, addClass, removeAllClass } from '@src/util/dom';\nimport { ERROR } from '@src/types';\nimport { initDefaultStylesheet } from '@src/painter/style';\nimport {\n    ID_DIVISION,\n    eventEmitter,\n    DATASET_IDENTIFIER,\n    INTERNAL_ERROR_EVENT,\n    CAMEL_DATASET_IDENTIFIER,\n    CAMEL_DATASET_IDENTIFIER_EXTRA,\n} from '@src/util/const';\n\nexport default class Painter {\n    options: PainterOptions;\n\n    $style: HTMLStyleElement;\n\n    styleId: string;\n\n    hooks: HookMap;\n\n    constructor(options: PainterOptions, hooks: HookMap) {\n        this.options = {\n            $root: options.$root,\n            wrapTag: options.wrapTag,\n            exceptSelectors: options.exceptSelectors,\n            className: options.className,\n        };\n        this.hooks = hooks;\n\n        initDefaultStylesheet();\n    }\n\n    /* =========================== render =========================== */\n    highlightRange(range: HighlightRange): HTMLElement[] {\n        if (!range.frozen) {\n            throw ERROR.HIGHLIGHT_RANGE_FROZEN;\n        }\n\n        const { $root, className, exceptSelectors } = this.options;\n        const hooks = this.hooks;\n\n        let $selectedNodes = getSelectedNodes($root, range.start, range.end, exceptSelectors);\n\n        if (!hooks.Render.SelectedNodes.isEmpty()) {\n            $selectedNodes = hooks.Render.SelectedNodes.call(range.id, $selectedNodes) || [];\n        }\n\n        return $selectedNodes.map(n => {\n            let $node = wrapHighlight(n, range, className, this.options.wrapTag);\n\n            if (!hooks.Render.WrapNode.isEmpty()) {\n                $node = hooks.Render.WrapNode.call(range.id, $node);\n            }\n\n            return $node;\n        });\n    }\n\n    highlightSource(sources: HighlightSource | HighlightSource[]): HighlightSource[] {\n        const list = Array.isArray(sources) ? sources : [sources];\n\n        const renderedSources: HighlightSource[] = [];\n\n        list.forEach(s => {\n            if (!(s instanceof HighlightSource)) {\n                eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                    type: ERROR.SOURCE_TYPE_ERROR,\n                });\n\n                return;\n            }\n\n            const range = s.deSerialize(this.options.$root, this.hooks);\n            const $nodes = this.highlightRange(range);\n\n            if ($nodes.length > 0) {\n                renderedSources.push(s);\n            } else {\n                eventEmitter.emit(INTERNAL_ERROR_EVENT, {\n                    type: ERROR.HIGHLIGHT_SOURCE_NONE_RENDER,\n                    detail: s,\n                });\n            }\n        });\n\n        return renderedSources;\n    }\n    /* ============================================================== */\n\n    /* =========================== clean =========================== */\n    // id: target id - highlight with this id should be clean\n    // if there is no highlight for this id, it will return false, vice versa\n    removeHighlight(id: string): boolean {\n        // whether extra ids contains the target id\n        const reg = new RegExp(`(${id}\\\\${ID_DIVISION}|\\\\${ID_DIVISION}?${id}$)`);\n\n        const hooks = this.hooks;\n        const wrapTag = this.options.wrapTag;\n        const $spans = document.querySelectorAll<HTMLElement>(`${wrapTag}[data-${DATASET_IDENTIFIER}]`);\n\n        // nodes to remove\n        const $toRemove: HTMLElement[] = [];\n        // nodes to update main id\n        const $idToUpdate: HTMLElement[] = [];\n        // nodes to update extra id\n        const $extraToUpdate: HTMLElement[] = [];\n\n        for (const $s of $spans) {\n            const spanId = $s.dataset[CAMEL_DATASET_IDENTIFIER];\n            const spanExtraIds = $s.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA];\n\n            // main id is the target id and no extra ids --> to remove\n            if (spanId === id && !spanExtraIds) {\n                $toRemove.push($s);\n            }\n            // main id is the target id but there is some extra ids -> update main id & extra id\n            else if (spanId === id) {\n                $idToUpdate.push($s);\n            }\n            // main id isn't the target id but extra ids contains it -> just remove it from extra id\n            else if (spanId !== id && reg.test(spanExtraIds)) {\n                $extraToUpdate.push($s);\n            }\n        }\n\n        $toRemove.forEach($s => {\n            const $parent = $s.parentNode;\n            const $fr = document.createDocumentFragment();\n\n            forEach($s.childNodes, ($c: Node) => $fr.appendChild($c.cloneNode(false)));\n\n            const $prev = $s.previousSibling;\n            const $next = $s.nextSibling;\n\n            $parent.replaceChild($fr, $s);\n            // there are bugs in IE11, so use a more reliable function\n            normalizeSiblingText($prev, true);\n            normalizeSiblingText($next, false);\n            hooks.Remove.UpdateNodes.call(id, $s, 'remove');\n        });\n\n        $idToUpdate.forEach($s => {\n            const dataset = $s.dataset;\n            const ids = dataset[CAMEL_DATASET_IDENTIFIER_EXTRA].split(ID_DIVISION);\n            const newId = ids.shift();\n\n            // find overlapped wrapper associated with \"extra id\"\n            const $overlapSpan = document.querySelector<HTMLElement>(\n                `${wrapTag}[data-${DATASET_IDENTIFIER}=\"${newId}\"]`,\n            );\n\n            if ($overlapSpan) {\n                // empty the current class list\n                removeAllClass($s);\n                // retain the class list of the overlapped wrapper which associated with \"extra id\"\n                addClass($s, [...$overlapSpan.classList]);\n            }\n\n            dataset[CAMEL_DATASET_IDENTIFIER] = newId;\n            dataset[CAMEL_DATASET_IDENTIFIER_EXTRA] = ids.join(ID_DIVISION);\n\n            hooks.Remove.UpdateNodes.call(id, $s, 'id-update');\n        });\n\n        $extraToUpdate.forEach($s => {\n            const extraIds = $s.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA];\n\n            $s.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA] = extraIds.replace(reg, '');\n            hooks.Remove.UpdateNodes.call(id, $s, 'extra-update');\n        });\n\n        return $toRemove.length + $idToUpdate.length + $extraToUpdate.length !== 0;\n    }\n\n    removeAllHighlight() {\n        const { wrapTag, $root } = this.options;\n        const $spans = getHighlightsByRoot($root, wrapTag);\n\n        $spans.forEach($s => {\n            const $parent = $s.parentNode;\n            const $fr = document.createDocumentFragment();\n\n            forEach($s.childNodes, ($c: Node) => $fr.appendChild($c.cloneNode(false)));\n            $parent.replaceChild($fr, $s);\n        });\n    }\n    /* ============================================================== */\n}\n","import type HighlightRange from '@src/model/range';\nimport type { SelectedNode, DomNode } from '@src/types';\nimport { SplitType, SelectedNodeType } from '@src/types';\nimport { hasClass, addClass as addElementClass, isHighlightWrapNode, removeAllClass } from '@src/util/dom';\nimport {\n    ID_DIVISION,\n    getDefaultOptions,\n    CAMEL_DATASET_IDENTIFIER,\n    CAMEL_DATASET_IDENTIFIER_EXTRA,\n    DATASET_IDENTIFIER,\n    DATASET_SPLIT_TYPE,\n    DATASET_IDENTIFIER_EXTRA,\n} from '../util/const';\nimport { unique } from '../util/tool';\n\n/**\n * 支持的选择器类型\n *  - class: .title, .main-nav\n *  - id: #nav, #js-toggle-btn\n *  - tag: div, p, span\n */\nconst isMatchSelector = ($node: HTMLElement, selector: string): boolean => {\n    if (!$node) {\n        return false;\n    }\n\n    if (/^\\./.test(selector)) {\n        const className = selector.replace(/^\\./, '');\n\n        return $node && hasClass($node, className);\n    } else if (/^#/.test(selector)) {\n        const id = selector.replace(/^#/, '');\n\n        return $node && $node.id === id;\n    }\n\n    const tagName = selector.toUpperCase();\n\n    return $node && $node.tagName === tagName;\n};\n\n/**\n * If start node and end node is the same, don't need to tranvers the dom tree.\n */\nconst getNodesIfSameStartEnd = (\n    $startNode: Text,\n    startOffset: number,\n    endOffset: number,\n    exceptSelectors?: string[],\n) => {\n    let $element = $startNode as Node;\n\n    const isExcepted = ($e: HTMLElement) => exceptSelectors?.some(s => isMatchSelector($e, s));\n\n    while ($element) {\n        if ($element.nodeType === 1 && isExcepted($element as HTMLElement)) {\n            return [];\n        }\n\n        $element = $element.parentNode;\n    }\n\n    $startNode.splitText(startOffset);\n\n    const passedNode = $startNode.nextSibling as Text;\n\n    passedNode.splitText(endOffset - startOffset);\n\n    return [\n        {\n            $node: passedNode,\n            type: SelectedNodeType.text,\n            splitType: SplitType.both,\n        },\n    ];\n};\n\n/**\n * get all the dom nodes between the start and end node\n */\nexport const getSelectedNodes = (\n    $root: Document | HTMLElement,\n    start: DomNode,\n    end: DomNode,\n    exceptSelectors: string[],\n): SelectedNode[] => {\n    const $startNode = start.$node;\n    const $endNode = end.$node;\n    const startOffset = start.offset;\n    const endOffset = end.offset;\n\n    // split current node when the start-node and end-node is the same\n    if ($startNode === $endNode && $startNode instanceof Text) {\n        return getNodesIfSameStartEnd($startNode, startOffset, endOffset, exceptSelectors);\n    }\n\n    const nodeStack: (ChildNode | Document | HTMLElement | Text)[] = [$root];\n    const selectedNodes: SelectedNode[] = [];\n\n    const isExcepted = ($e: HTMLElement) => exceptSelectors?.some(s => isMatchSelector($e, s));\n\n    let withinSelectedRange = false;\n    let curNode: Node = null;\n\n    while ((curNode = nodeStack.pop())) {\n        // do not traverse the excepted node\n        if (curNode.nodeType === 1 && isExcepted(curNode as HTMLElement)) {\n            continue;\n        }\n\n        const children = curNode.childNodes;\n\n        for (let i = children.length - 1; i >= 0; i--) {\n            nodeStack.push(children[i]);\n        }\n\n        // only collect text nodes\n        if (curNode === $startNode) {\n            if (curNode.nodeType === 3) {\n                (curNode as Text).splitText(startOffset);\n\n                const node = curNode.nextSibling as Text;\n\n                selectedNodes.push({\n                    $node: node,\n                    type: SelectedNodeType.text,\n                    splitType: SplitType.head,\n                });\n            }\n\n            // meet the start-node (begin to traverse)\n            withinSelectedRange = true;\n        } else if (curNode === $endNode) {\n            if (curNode.nodeType === 3) {\n                const node = curNode as Text;\n\n                node.splitText(endOffset);\n                selectedNodes.push({\n                    $node: node,\n                    type: SelectedNodeType.text,\n                    splitType: SplitType.tail,\n                });\n            }\n\n            // meet the end-node\n            break;\n        }\n        // handle text nodes between the range\n        else if (withinSelectedRange && curNode.nodeType === 3) {\n            selectedNodes.push({\n                $node: curNode as Text,\n                type: SelectedNodeType.text,\n                splitType: SplitType.none,\n            });\n        }\n    }\n\n    return selectedNodes;\n};\n\nconst addClass = ($el: HTMLElement, className?: string[] | string): HTMLElement => {\n    let classNames = Array.isArray(className) ? className : [className];\n\n    classNames = classNames.length === 0 ? [getDefaultOptions().style.className] : classNames;\n    classNames.forEach(c => {\n        addElementClass($el, c);\n    });\n\n    return $el;\n};\n\nconst isNodeEmpty = ($n: Node): boolean => !$n || !$n.textContent;\n\n/**\n * Wrap a common wrapper.\n */\nconst wrapNewNode = (\n    selected: SelectedNode,\n    range: HighlightRange,\n    className: string[] | string,\n    wrapTag: string,\n): HTMLElement => {\n    const $wrap = document.createElement(wrapTag);\n\n    addClass($wrap, className);\n\n    $wrap.appendChild(selected.$node.cloneNode(false));\n    selected.$node.parentNode.replaceChild($wrap, selected.$node);\n\n    $wrap.setAttribute(`data-${DATASET_IDENTIFIER}`, range.id);\n    $wrap.setAttribute(`data-${DATASET_SPLIT_TYPE}`, selected.splitType);\n    $wrap.setAttribute(`data-${DATASET_IDENTIFIER_EXTRA}`, '');\n\n    return $wrap;\n};\n\n/**\n * Split and wrapper each one.\n */\nconst wrapPartialNode = (\n    selected: SelectedNode,\n    range: HighlightRange,\n    className: string[] | string,\n    wrapTag: string,\n): HTMLElement => {\n    const $wrap: HTMLElement = document.createElement(wrapTag);\n\n    const $parent = selected.$node.parentNode as HTMLElement;\n    const $prev = selected.$node.previousSibling;\n    const $next = selected.$node.nextSibling;\n    const $fr = document.createDocumentFragment();\n    const parentId = $parent.dataset[CAMEL_DATASET_IDENTIFIER];\n    const parentExtraId = $parent.dataset[CAMEL_DATASET_IDENTIFIER_EXTRA];\n    const extraInfo = parentExtraId ? parentId + ID_DIVISION + parentExtraId : parentId;\n\n    $wrap.setAttribute(`data-${DATASET_IDENTIFIER}`, range.id);\n    $wrap.setAttribute(`data-${DATASET_IDENTIFIER_EXTRA}`, extraInfo);\n    $wrap.appendChild(selected.$node.cloneNode(false));\n\n    let headSplit = false;\n    let tailSplit = false;\n    let splitType: SplitType;\n\n    if ($prev) {\n        const $span = $parent.cloneNode(false);\n\n        $span.textContent = $prev.textContent;\n        $fr.appendChild($span);\n        headSplit = true;\n    }\n\n    const classNameList: string[] = [];\n\n    if (Array.isArray(className)) {\n        classNameList.push(...className);\n    } else {\n        classNameList.push(className);\n    }\n\n    addClass($wrap, unique(classNameList));\n    $fr.appendChild($wrap);\n\n    if ($next) {\n        const $span = $parent.cloneNode(false);\n\n        $span.textContent = $next.textContent;\n        $fr.appendChild($span);\n        tailSplit = true;\n    }\n\n    if (headSplit && tailSplit) {\n        splitType = SplitType.both;\n    } else if (headSplit) {\n        splitType = SplitType.head;\n    } else if (tailSplit) {\n        splitType = SplitType.tail;\n    } else {\n        splitType = SplitType.none;\n    }\n\n    $wrap.setAttribute(`data-${DATASET_SPLIT_TYPE}`, splitType);\n    $parent.parentNode.replaceChild($fr, $parent);\n\n    return $wrap;\n};\n\n/**\n * Just update id info (no wrapper updated).\n */\nconst wrapOverlapNode = (selected: SelectedNode, range: HighlightRange, className: string[] | string): HTMLElement => {\n    const $parent = selected.$node.parentNode as HTMLElement;\n    const $wrap: HTMLElement = $parent;\n\n    removeAllClass($wrap);\n    addClass($wrap, className);\n\n    const dataset = $parent.dataset;\n    const formerId = dataset[CAMEL_DATASET_IDENTIFIER];\n\n    dataset[CAMEL_DATASET_IDENTIFIER] = range.id;\n    dataset[CAMEL_DATASET_IDENTIFIER_EXTRA] = dataset[CAMEL_DATASET_IDENTIFIER_EXTRA]\n        ? formerId + ID_DIVISION + dataset[CAMEL_DATASET_IDENTIFIER_EXTRA]\n        : formerId;\n\n    return $wrap;\n};\n\n/**\n * wrap a dom node with highlight wrapper\n *\n * Because of supporting the highlight-overlapping,\n * Highlighter can't just wrap all nodes in a simple way.\n * There are three types:\n *  - wrapping a whole new node (without any wrapper)\n *  - wrapping part of the node\n *  - wrapping the whole wrapped node\n */\nexport const wrapHighlight = (\n    selected: SelectedNode,\n    range: HighlightRange,\n    className: string[] | string,\n    wrapTag: string,\n): HTMLElement => {\n    const $parent = selected.$node.parentNode as HTMLElement;\n    const $prev = selected.$node.previousSibling;\n    const $next = selected.$node.nextSibling;\n\n    let $wrap: HTMLElement;\n\n    // text node, not in a highlight wrapper -> should be wrapped in a highlight wrapper\n    if (!isHighlightWrapNode($parent)) {\n        $wrap = wrapNewNode(selected, range, className, wrapTag);\n    }\n    // text node, in a highlight wrap -> should split the existing highlight wrapper\n    else if (isHighlightWrapNode($parent) && (!isNodeEmpty($prev) || !isNodeEmpty($next))) {\n        $wrap = wrapPartialNode(selected, range, className, wrapTag);\n    }\n    // completely overlap (with a highlight wrap) -> only add extra id info\n    else {\n        $wrap = wrapOverlapNode(selected, range, className);\n    }\n\n    return $wrap;\n};\n\n/**\n * merge the adjacent text nodes\n * .normalize() API has some bugs in IE11\n */\nexport const normalizeSiblingText = ($s: Node, isNext = true) => {\n    if (!$s || $s.nodeType !== 3) {\n        return;\n    }\n\n    const $sibling = isNext ? $s.nextSibling : $s.previousSibling;\n\n    if ($sibling.nodeType !== 3) {\n        return;\n    }\n\n    const text = $sibling.nodeValue;\n\n    $s.nodeValue = isNext ? $s.nodeValue + text : text + $s.nodeValue;\n    $sibling.parentNode.removeChild($sibling);\n};\n","/**\n * support IE 10\n */\nexport const unique = <T>(arr: T[]): T[] => {\n    const res: T[] = [];\n\n    for (const el of arr) {\n        if (res.indexOf(el) === -1) {\n            res.push(el);\n        }\n    }\n\n    return res;\n};\n","/**\n * inject styles\n */\nimport { STYLESHEET_ID, getStylesheet } from '@src/util/const';\n\nexport const initDefaultStylesheet = () => {\n    const styleId = STYLESHEET_ID;\n\n    let $style: HTMLStyleElement = document.getElementById(styleId) as HTMLStyleElement;\n\n    if (!$style) {\n        const $cssNode = document.createTextNode(getStylesheet());\n\n        $style = document.createElement('style');\n        $style.id = styleId;\n        $style.appendChild($cssNode);\n        document.head.appendChild($style);\n    }\n\n    return $style;\n};\n"],"sourceRoot":""}